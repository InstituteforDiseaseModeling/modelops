"""Job submission CLI commands.

This module provides a thin CLI wrapper around the JobSubmissionClient
for submitting simulation and calibration jobs to the cluster.
"""

import json
import typer
from pathlib import Path
from typing import Optional

from modelops_contracts import SimulationStudy, CalibrationSpec

from ..client import JobSubmissionClient
from .display import console, success, error, info, warning, section
from .common_options import env_option

app = typer.Typer(help="Submit and manage simulation jobs")


@app.command()
def submit(
    study_file: Path = typer.Argument(
        ...,
        help="SimulationStudy JSON file",
        exists=True,
        file_okay=True,
        readable=True,
    ),
    bundle: Optional[str] = typer.Option(
        None, "--bundle", "-b", help="Explicit bundle reference (sha256:...)"
    ),
    auto: bool = typer.Option(
        False, "--auto", help="Auto-push bundle from current directory"
    ),
    env: Optional[str] = env_option(),
):
    """Submit a SimulationStudy as a K8s Job.

    The study file should be generated by Calabaria's sampling commands
    (e.g., 'cb sampling sobol'). The job specification will be uploaded
    to blob storage to avoid ConfigMap size limits.

    Examples:
        # Auto-push current directory and submit
        mops jobs submit study.json --auto

        # Use explicit bundle digest
        mops jobs submit study.json --bundle sha256:abc123...
    """
    # Use config default if env not specified
    from .utils import resolve_env
    env = resolve_env(env)

    # Load study from JSON
    section("Loading simulation study")
    try:
        with open(study_file) as f:
            study_data = json.load(f)

        # Reconstruct SimulationStudy
        # Extract just the parameter dictionaries (not UniqueParameterSet objects)
        parameter_sets = [
            ps["params"] if isinstance(ps, dict) and "params" in ps else ps
            for ps in study_data.get("parameter_sets", [])
        ]

        study = SimulationStudy(
            model=study_data["model"],
            scenario=study_data["scenario"],
            parameter_sets=parameter_sets,
            sampling_method=study_data["sampling_method"],
            n_replicates=study_data.get("n_replicates", 1),
            outputs=study_data.get("outputs"),
            targets=study_data.get("targets"),  # Support targets in study
            metadata=study_data.get("metadata", {}),
        )

        info(f"  Model: {study.model}/{study.scenario}")
        info(f"  Parameters: {study.parameter_count()} unique sets")
        info(f"  Replicates: {study.n_replicates} per parameter set")
        info(f"  Total simulations: {study.total_simulation_count()}")
        if study.targets:
            info(f"  Targets: {', '.join(study.targets)}")

    except Exception as e:
        error(f"Failed to load study file: {e}")
        raise typer.Exit(1)

    # Determine bundle reference
    if auto and bundle:
        error("Cannot use both --auto and --bundle")
        raise typer.Exit(1)

    if auto:
        # Auto-push bundle from current directory
        section("Auto-pushing bundle")
        try:
            from modelops_bundle.api import push_dir
            from modelops_bundle.ops import load_config

            info("  Building and pushing bundle from current directory...")
            digest = push_dir(".")

            # Get repository name from bundle config
            try:
                config = load_config()
                registry_ref = config.registry_ref  # e.g. "acr.io/my-project"

                # Extract repository name from registry_ref
                if '/' in registry_ref:
                    repository_name = registry_ref.split('/', 1)[1]
                    bundle_ref = f"{repository_name}@{digest}"
                else:
                    # Fallback to digest-only if parsing fails
                    warning(f"  Could not parse repository from registry_ref: {registry_ref}")
                    bundle_ref = digest
            except Exception as e:
                warning(f"  Could not load bundle config: {e}")
                warning("  Using digest-only reference")
                bundle_ref = digest

            success(f"  âœ“ Pushed bundle: {bundle_ref[:50]}...")

        except ImportError:
            error("\nAuto-push requires modelops-bundle. Install with:")
            error("  uv pip install 'modelops[bundle]'")
            raise typer.Exit(1)
        except FileNotFoundError:
            error("\nCurrent directory is not a bundle project.")
            error("Initialize with: modelops-bundle init .")
            raise typer.Exit(1)
        except Exception as e:
            error(f"\nBundle push failed: {e}")
            raise typer.Exit(1)
    elif bundle:
        bundle_ref = bundle
        info(f"\nðŸ“¦ Using explicit bundle: {bundle_ref[:20]}...")
    else:
        error("Must specify either --bundle or --auto")
        raise typer.Exit(1)

    # Submit using client
    section("Submitting job")
    client = JobSubmissionClient(env=env)

    try:
        job_id = client.submit_sim_job(
            study=study, bundle_strategy="explicit", bundle_ref=bundle_ref
        )

        success(f"\nâœ“ Job submitted successfully!")
        info(f"  Job ID: {job_id}")
        info(f"  Environment: {env}")
        info(f"  Status: Running")

        # Show how to check status
        info("\nðŸ“Š To check job status:")
        info(f"  kubectl -n modelops-dask-dev get job job-{job_id}")
        info("\nðŸ“‹ To see logs:")
        info(f"  kubectl -n modelops-dask-dev logs job/job-{job_id}")

    except Exception as e:
        error(f"Job submission failed: {e}")
        raise typer.Exit(1)


@app.command()
def submit_calibration(
    spec_file: Path = typer.Argument(
        ...,
        help="CalibrationSpec JSON file",
        exists=True,
        file_okay=True,
        readable=True,
    ),
    bundle: Optional[str] = typer.Option(
        None, "--bundle", "-b", help="Explicit bundle reference"
    ),
    build: bool = typer.Option(False, "--build", help="Build and push bundle"),
    latest: bool = typer.Option(False, "--latest", help="Use latest bundle"),
    env: Optional[str] = env_option(),
):
    """Submit a CalibrationSpec as a K8s Job.

    Calibration jobs run an adaptive algorithm (e.g., Optuna) that
    iteratively generates parameters and evaluates them.
    """
    env = env or "dev"

    # Load calibration spec
    section("Loading calibration specification")
    try:
        with open(spec_file) as f:
            spec_data = json.load(f)

        spec = CalibrationSpec(
            model=spec_data["model"],
            scenario=spec_data["scenario"],
            algorithm=spec_data["algorithm"],
            target_data=spec_data["target_data"],
            max_iterations=spec_data["max_iterations"],
            convergence_criteria=spec_data.get("convergence_criteria", {}),
            algorithm_config=spec_data.get("algorithm_config", {}),
            outputs=spec_data.get("outputs"),
            metadata=spec_data.get("metadata", {}),
        )

        info(f"  Model: {spec.model}/{spec.scenario}")
        info(f"  Algorithm: {spec.algorithm}")
        info(f"  Max iterations: {spec.max_iterations}")

    except Exception as e:
        error(f"Failed to load calibration spec: {e}")
        raise typer.Exit(1)

    # Determine bundle strategy
    if build:
        strategy = "build"
        bundle_ref = None
    elif latest:
        strategy = "latest"
        bundle_ref = None
    elif bundle:
        strategy = "explicit"
        bundle_ref = bundle
    else:
        error("Must specify --bundle, --latest, or --build")
        raise typer.Exit(1)

    # Submit using client
    section("Submitting calibration job")
    client = JobSubmissionClient(env=env)

    try:
        job_id = client.submit_calibration_job(
            spec=spec, bundle_strategy=strategy, bundle_ref=bundle_ref
        )

        success(f"\nâœ“ Calibration job submitted successfully!")
        info(f"  Job ID: {job_id}")
        info(f"  Environment: {env}")

    except Exception as e:
        error(f"Calibration submission failed: {e}")
        raise typer.Exit(1)


@app.command()
def status(
    job_id: str = typer.Argument(..., help="Job ID to check"),
    env: Optional[str] = env_option(),
):
    """Check the status of a submitted job.

    This is a placeholder for future implementation that would
    query the K8s API and blob storage for comprehensive status.
    """
    env = env or "dev"

    warning("Status command not yet implemented")
    info("\nðŸ’¡ For now, use kubectl directly:")
    info(f"  kubectl -n modelops-dask-dev get job job-{job_id}")
    info(f"  kubectl -n modelops-dask-dev describe job job-{job_id}")


@app.command()
def logs(
    job_id: str = typer.Argument(..., help="Job ID to get logs for"),
    follow: bool = typer.Option(False, "--follow", "-f", help="Follow log output"),
    env: Optional[str] = env_option(),
):
    """Get logs for a running or completed job.

    This is a placeholder for future implementation that would
    stream logs from the K8s Job pod.
    """
    env = env or "dev"

    warning("Logs command not yet implemented")
    info("\nðŸ’¡ For now, use kubectl directly:")
    if follow:
        info(f"  kubectl -n modelops-dask-dev logs -f job/job-{job_id}")
    else:
        info(f"  kubectl -n modelops-dask-dev logs job/job-{job_id}")


@app.command()
def list(
    limit: int = typer.Option(10, "--limit", "-n", help="Number of jobs to show"),
    env: Optional[str] = env_option(),
):
    """List recent jobs.

    This is a placeholder for future implementation that would
    query blob storage for submitted jobs and their status.
    """
    env = env or "dev"

    warning("List command not yet implemented")
    info("\nðŸ’¡ For now, use kubectl directly:")
    info("  kubectl -n modelops-dask-dev get jobs")


if __name__ == "__main__":
    app()